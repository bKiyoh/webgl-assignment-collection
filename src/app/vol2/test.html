<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - postprocessing - godrays</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>

  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      - webgl god-rays example - tree by
      <a
        href="http://www.turbosquid.com/3d-models/free-tree-3d-model/592617"
        target="_blank"
        rel="noopener"
        >stanloshka</a
      >
    </div>

    <!-- 必要なモジュールを読み込むためのインポートマップ -->
    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      // three.jsの必要なモジュールをインポート
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import {
        GodRaysFakeSunShader,
        GodRaysDepthMaskShader,
        GodRaysCombineShader,
        GodRaysGenerateShader,
      } from "three/addons/shaders/GodRaysShader.js";

      let container, stats;
      let camera, scene, renderer, materialDepth;

      let sphereMesh;

      const sunPosition = new THREE.Vector3(0, 1000, -1000);
      const clipPosition = new THREE.Vector4();
      // スクリーン空間の位置
      const screenSpacePosition = new THREE.Vector3();
      // ポストプロセシングの設定
      const postprocessing = { enabled: true };
      // ゴッドレイのパラメータ
      const orbitRadius = 200;

      const bgColor = 0x000511;
      const sunColor = 0xffee00;

      // ゴッドレイのレンダリングターゲットの解像度を小さくしてパフォーマンスを向上
      const godrayRenderTargetResolutionMultiplier = 1.0 / 4.0;

      init();
      animate();

      function init() {
        // コンテナの作成
        container = document.createElement("div");
        document.body.appendChild(container);

        // カメラの設定
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          1,
          3000
        );
        camera.position.z = 200;

        // シーンの作成
        scene = new THREE.Scene();

        // デプスマテリアルの設定
        materialDepth = new THREE.MeshDepthMaterial();

        // ツリーモデルの読み込み
        const loader = new OBJLoader();
        loader.load("models/obj/tree.obj", function (object) {
          object.position.set(0, -150, -150);
          object.scale.multiplyScalar(400);
          scene.add(object);
        });

        // 球体の作成
        const geo = new THREE.SphereGeometry(1, 20, 10);
        sphereMesh = new THREE.Mesh(
          geo,
          new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        sphereMesh.scale.multiplyScalar(20);
        scene.add(sphereMesh);

        // レンダラーの設定
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;

        // オービットコントロールの設定
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 50;
        controls.maxDistance = 500;

        // ステータスの設定
        stats = new Stats();
        // これは、ステータスパネルの表示位置を変更します。
        container.appendChild(stats.dom);

        // ウィンドウのリサイズイベントを処理
        window.addEventListener("resize", onWindowResize);

        // ポストプロセシングの初期化
        initPostprocessing(window.innerWidth, window.innerHeight);
      }

      // ウィンドウリサイズ時の処理
      function onWindowResize() {
        const renderTargetWidth = window.innerWidth;
        const renderTargetHeight = window.innerHeight;

        camera.aspect = renderTargetWidth / renderTargetHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(renderTargetWidth, renderTargetHeight);
        postprocessing.rtTextureColors.setSize(
          renderTargetWidth,
          renderTargetHeight
        );
        postprocessing.rtTextureDepth.setSize(
          renderTargetWidth,
          renderTargetHeight
        );
        postprocessing.rtTextureDepthMask.setSize(
          renderTargetWidth,
          renderTargetHeight
        );

        const adjustedWidth =
          renderTargetWidth * godrayRenderTargetResolutionMultiplier;
        const adjustedHeight =
          renderTargetHeight * godrayRenderTargetResolutionMultiplier;
        postprocessing.rtTextureGodRays1.setSize(adjustedWidth, adjustedHeight);
        postprocessing.rtTextureGodRays2.setSize(adjustedWidth, adjustedHeight);
      }

      // ポストプロセシング要素の初期化
      function initPostprocessing(renderTargetWidth, renderTargetHeight) {
        postprocessing.scene = new THREE.Scene();

        postprocessing.camera = new THREE.OrthographicCamera(
          -0.5,
          0.5,
          0.5,
          -0.5,
          -10000,
          10000
        );
        postprocessing.camera.position.z = 100;
        postprocessing.scene.add(postprocessing.camera);

        postprocessing.rtTextureColors = new THREE.WebGLRenderTarget(
          renderTargetWidth,
          renderTargetHeight,
          { type: THREE.HalfFloatType }
        );
        postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget(
          renderTargetWidth,
          renderTargetHeight,
          { type: THREE.HalfFloatType }
        );
        postprocessing.rtTextureDepthMask = new THREE.WebGLRenderTarget(
          renderTargetWidth,
          renderTargetHeight,
          { type: THREE.HalfFloatType }
        );

        const adjustedWidth =
          renderTargetWidth * godrayRenderTargetResolutionMultiplier;
        const adjustedHeight =
          renderTargetHeight * godrayRenderTargetResolutionMultiplier;
        postprocessing.rtTextureGodRays1 = new THREE.WebGLRenderTarget(
          adjustedWidth,
          adjustedHeight,
          { type: THREE.HalfFloatType }
        );
        postprocessing.rtTextureGodRays2 = new THREE.WebGLRenderTarget(
          adjustedWidth,
          adjustedHeight,
          { type: THREE.HalfFloatType }
        );

        const godraysMaskShader = GodRaysDepthMaskShader;
        postprocessing.godrayMaskUniforms = THREE.UniformsUtils.clone(
          godraysMaskShader.uniforms
        );
        postprocessing.materialGodraysDepthMask = new THREE.ShaderMaterial({
          uniforms: postprocessing.godrayMaskUniforms,
          vertexShader: godraysMaskShader.vertexShader,
          fragmentShader: godraysMaskShader.fragmentShader,
        });

        const godraysGenShader = GodRaysGenerateShader;
        postprocessing.godrayGenUniforms = THREE.UniformsUtils.clone(
          godraysGenShader.uniforms
        );
        postprocessing.materialGodraysGenerate = new THREE.ShaderMaterial({
          uniforms: postprocessing.godrayGenUniforms,
          vertexShader: godraysGenShader.vertexShader,
          fragmentShader: godraysGenShader.fragmentShader,
        });

        const godraysCombineShader = GodRaysCombineShader;
        postprocessing.godrayCombineUniforms = THREE.UniformsUtils.clone(
          godraysCombineShader.uniforms
        );
        postprocessing.materialGodraysCombine = new THREE.ShaderMaterial({
          uniforms: postprocessing.godrayCombineUniforms,
          vertexShader: godraysCombineShader.vertexShader,
          fragmentShader: godraysCombineShader.fragmentShader,
        });

        const godraysFakeSunShader = GodRaysFakeSunShader;
        postprocessing.godraysFakeSunUniforms = THREE.UniformsUtils.clone(
          godraysFakeSunShader.uniforms
        );
        postprocessing.materialGodraysFakeSun = new THREE.ShaderMaterial({
          uniforms: postprocessing.godraysFakeSunUniforms,
          vertexShader: godraysFakeSunShader.vertexShader,
          fragmentShader: godraysFakeSunShader.fragmentShader,
        });

        postprocessing.godraysFakeSunUniforms.bgColor.value.setHex(bgColor);
        postprocessing.godraysFakeSunUniforms.sunColor.value.setHex(sunColor);

        postprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;

        postprocessing.quad = new THREE.Mesh(
          new THREE.PlaneGeometry(1.0, 1.0),
          postprocessing.materialGodraysGenerate
        );
        postprocessing.quad.position.z = -9900;
        postprocessing.scene.add(postprocessing.quad);
      }

      // シーンのアニメーション
      function animate() {
        requestAnimationFrame(animate);

        stats.begin();
        render();
        stats.end();
      }

      // ゴッドレイのフィルタリングステップサイズの計算
      function getStepSize(filterLen, tapsPerPass, pass) {
        return filterLen * Math.pow(tapsPerPass, -pass);
      }

      // ゴッドレイのフィルタリング
      function filterGodRays(inputTex, renderTarget, stepSize) {
        postprocessing.scene.overrideMaterial =
          postprocessing.materialGodraysGenerate;

        postprocessing.godrayGenUniforms["fStepSize"].value = stepSize;
        postprocessing.godrayGenUniforms["tInput"].value = inputTex;

        renderer.setRenderTarget(renderTarget);
        renderer.render(postprocessing.scene, postprocessing.camera);
        postprocessing.scene.overrideMaterial = null;
      }

      // シーンのレンダリング
      function render() {
        const time = Date.now() / 4000;

        // 球体の位置を時間に応じて更新
        sphereMesh.position.x = orbitRadius * Math.cos(time);
        sphereMesh.position.z = orbitRadius * Math.sin(time) - 100;

        if (postprocessing.enabled) {
          clipPosition.x = sunPosition.x;
          clipPosition.y = sunPosition.y;
          clipPosition.z = sunPosition.z;
          clipPosition.w = 1;

          clipPosition
            .applyMatrix4(camera.matrixWorldInverse)
            .applyMatrix4(camera.projectionMatrix);

          // 透視投影を行い、NDC空間に変換
          clipPosition.x /= clipPosition.w;
          clipPosition.y /= clipPosition.w;

          screenSpacePosition.x = (clipPosition.x + 1) / 2; // [-1,1]から[0,1]に変換
          screenSpacePosition.y = (clipPosition.y + 1) / 2; // [-1,1]から[0,1]に変換
          screenSpacePosition.z = clipPosition.z; // クリップ空間に保持

          // ゴッドレイと太陽のシェーダーに渡す
          postprocessing.godrayGenUniforms[
            "vSunPositionScreenSpace"
          ].value.copy(screenSpacePosition);
          postprocessing.godraysFakeSunUniforms[
            "vSunPositionScreenSpace"
          ].value.copy(screenSpacePosition);

          // -- 空と太陽を描画 --

          // カラーと深度をクリア、空の色でクリア
          renderer.setRenderTarget(postprocessing.rtTextureColors);
          renderer.clear(true, true, false);

          // 太陽のレンダリング
          const sunsqH = 0.74 * window.innerHeight; // シェーダーから太陽の範囲を依存
          const sunsqW = 0.74 * window.innerHeight; // 高さに依存、太陽はアスペクト補正される

          screenSpacePosition.x *= window.innerWidth;
          screenSpacePosition.y *= window.innerHeight;

          renderer.setScissor(
            screenSpacePosition.x - sunsqW / 2,
            screenSpacePosition.y - sunsqH / 2,
            sunsqW,
            sunsqH
          );
          renderer.setScissorTest(true);

          postprocessing.godraysFakeSunUniforms["fAspect"].value =
            window.innerWidth / window.innerHeight;

          postprocessing.scene.overrideMaterial =
            postprocessing.materialGodraysFakeSun;
          renderer.setRenderTarget(postprocessing.rtTextureColors);
          renderer.render(postprocessing.scene, postprocessing.camera);

          renderer.setScissorTest(false);

          // -- シーンオブジェクトの描画 --

          // カラー
          scene.overrideMaterial = null;
          renderer.setRenderTarget(postprocessing.rtTextureColors);
          renderer.render(scene, camera);

          // デプス
          scene.overrideMaterial = materialDepth;
          renderer.setRenderTarget(postprocessing.rtTextureDepth);
          renderer.clear();
          renderer.render(scene, camera);

          // デプスマスク
          postprocessing.godrayMaskUniforms["tInput"].value =
            postprocessing.rtTextureDepth.texture;
          postprocessing.scene.overrideMaterial =
            postprocessing.materialGodraysDepthMask;
          renderer.setRenderTarget(postprocessing.rtTextureDepthMask);
          renderer.render(postprocessing.scene, postprocessing.camera);

          // -- ゴッドレイのレンダリング --

          const filterLen = 1.0;
          const TAPS_PER_PASS = 6.0;

          // パス1 - 最初のピンポンターゲットにレンダリング
          filterGodRays(
            postprocessing.rtTextureDepthMask.texture,
            postprocessing.rtTextureGodRays2,
            getStepSize(filterLen, TAPS_PER_PASS, 1.0)
          );

          // パス2 - 2番目のピンポンターゲットにレンダリング
          filterGodRays(
            postprocessing.rtTextureGodRays2.texture,
            postprocessing.rtTextureGodRays1,
            getStepSize(filterLen, TAPS_PER_PASS, 2.0)
          );

          // パス3 - 1番目のレンダリングターゲット
          filterGodRays(
            postprocessing.rtTextureGodRays1.texture,
            postprocessing.rtTextureGodRays2,
            getStepSize(filterLen, TAPS_PER_PASS, 3.0)
          );

          // 最終パス - ゴッドレイをカラーに合成
          postprocessing.godrayCombineUniforms["tColors"].value =
            postprocessing.rtTextureColors.texture;
          postprocessing.godrayCombineUniforms["tGodRays"].value =
            postprocessing.rtTextureGodRays2.texture;

          postprocessing.scene.overrideMaterial =
            postprocessing.materialGodraysCombine;
          renderer.setRenderTarget(null);
          renderer.render(postprocessing.scene, postprocessing.camera);
          postprocessing.scene.overrideMaterial = null;
        } else {
          // 通常のレンダリング
          renderer.setRenderTarget(null);
          renderer.clear();
          renderer.render(scene, camera);
        }
      }
    </script>
  </body>
</html>
